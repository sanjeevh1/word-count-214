Alexander Ruan ajr331
Sanjeev Harikrishnan sh1720

Design Notes: 
Our source code consists of two C files, "words.c" and "arraylist.c", as well as a header file "arraylist.h". While "words.c" implements the logic for traversing through all given files and identifying words, the "arraylist.c" and "arraylist.h" files contain the implementation for a variable-length array-based data structure used to store key-value pairs that map each word to its word count.
To compile all necessary files, simply run "make" or "make words". To run the program, run "./words " followed by the desired test files.
Our code accounts for the following special cases: inability to open a file, empty files, files containing no words, long words, several words in a given file, hyphens at the beginning/end/middle of a word and at the beginning/end of a file, calling "./words" with an incorrect filename or no filename, and whitespace/punctuation/numbers at any point in the file, including the beginning and end and between words (including multiple consecutive whitespace/punctuation/numerical characters).

Testing strategy:

We tested our program by running it with various files that tested different aspects of our code.

Arguments: In order to ensure that our code could handle different types of arguments correctly, we tested it by passing regular text files, directories, non-text files, hidden directories/text/non-text files, multiple files, no files, and invalid path names to the program. In the last two cases, an error message is displayed indicating the correct way to use the program and the file(s) that could not be opened, and in all other cases, the words are counted normally. To ensure that each file was counted when passing multiple file names to the program, each file included a word that was unique to that file; if that word appeared in the final word count, then that file was processed normally, and if not, the file was not processed. Some words were repeated across files to ensure that our program correctly added the word counts across multiple files.

Directories: To test our program's ability to correctly traverse all files in a directory and skip all hidden files and non-directory files that don't end in ".txt", we passed a sample test directory to the program. The test directory contained hidden and non-hidden subdirectories, each with their own hidden and non-hidden files, ".txt" files, non-".txt" files, and hidden files (both ".txt" and non-".txt"). Once again, each file had at least one word that was unique to that file, so we could easily check which files were and were not processed by the program.

Parsing file contents: To ensure that our program correctly parses the contents of a file, we tested our program with all possible cases that could lead to different behavior. These cases include short words, long words, hyphens in the beginning/middle/end of a word, multiple consecutive hyphens, hyphens with no surrounding letters, hyphens with adjacent apostrophes, multiple non-letter characters in a row, non-letter and letter characters at the beginning/end of a file, hyphens at the beginning/end of a file, empty files, apostrophes at the beginning/middle/end of a word, and words that consist only of apostrophes. When creating these files, we kept in mind the initial buffer size used in our program to read the contents of a file and intentionally designed our files to contain words that might get split up by the buffer.

Sorting/Counting: Finally, to ensure that our array-based data structure correctly keeps track of all words and that the sorting of this array at the end works correctly, we created test files that have multiple words with the same word count as well as words with different word counts. Furthermore, these files contained words with higher word counts that come after words with lower word counts when sorted in lexicographical order. This way, if the words were not correctly sorted by decreasing word count first and only then by lexicographical order, the output of the program would be incorrect.     
